package main

import (
	"bufio"
	"fmt"
	"os"
)

//Головоломка <<Ханойские башни>> состоит из трёх стержней, пронумеруем их слева направо: 1, 2 и 3. Также в головоломке
//используется стопка дисков с отверстием посередине. Радиус дисков уменьшается снизу вверх. Изначально диски расположены
//на левом стержне (стержень 1), самый большой диск находится внизу. Диски в игре перемещаются по одному со стержня
//на стержень. Диск можно надеть на стержень, только если он пустой или верхний диск на нём большего размера,
//чем перемещаемый. Цель головоломки — перенести все диски со стержня 1 на стержень 3.
//
//Немного изменим правила. Теперь головоломка состоит из четырех стержней, а цель головоломки — перенести все диски
//со стержня 1 на стержень 4. Найдите минимальное количество ходов, за которое можно решить головоломку.

//В первой строке задано одно число n (3≤n≤10) — количество дисков на первой башне.
// В единственной строке выведите ответ на задачу.

// Пример1
//Ввод 3
//Вывод 5
//
//Пример 2
//Ввод 4
//Вывод 9
//
//Пример 3
//Ввод 5
//Вывод 13

func main() {
	in := bufio.NewReader(os.Stdin)
	out := bufio.NewWriter(os.Stdout)
	defer out.Flush()
	var n int
	fmt.Fscanln(in, &n)

	//var k int

	//k = n - int(math.Round(math.Sqrt(2*float64(n)+1))) + n

	//Алгоритм Фрейма — Стюарта
	//Алгоритм Фрейма — Стюарта, дающий оптимальное решение для четырёх и предположительно оптимальное решение для большего количества стержней, описывается следующим образом:
	//
	//Пусть
	//�
	//n — количество дисков.
	//Пусть
	//�
	//r — число стержней.
	//Определим
	//�
	//(
	//�
	//,
	//�
	//)
	//{\displaystyle T(n,r)} как наименьшее число ходов, необходимое для переноса n дисков с использованием r стержней.
	//Алгоритм может быть описан рекурсивно:
	//
	//Для некоторого
	//�
	//k,
	//1
	//≤
	//�
	//<
	//�
	//{\displaystyle 1\leq k<n}, перенести верхние
	//�
	//k на стержень i, не являющийся ни начальным, ни конечным стержнем, затратив на это
	//�
	//(
	//�
	//,
	//�
	//)
	//{\displaystyle T(k,r)} ходов.
	//Не используя стержень i, содержащий теперь верхние
	//�
	//k дисков, перенести оставшиеся
	//�
	//−
	//�
	//n-k дисков на конечный стержень, используя только оставшиеся
	//�
	//−
	//1
	//r-1 стержней и затратив на это
	//�
	//(
	//�
	//−
	//�
	//,
	//�
	//−
	//1
	//)
	//{\displaystyle T(n-k,r-1)} ходов.
	//Наконец, переместить верхние
	//�
	//k дисков на конечный стержень, затратив на это
	//�
	//(
	//�
	//,
	//�
	//)
	//{\displaystyle T(k,r)} ходов.
	//На весь процесс требуется
	//2
	//�
	//(
	//�
	//,
	//�
	//)
	//+
	//�
	//(
	//�
	//−
	//�
	//,
	//�
	//−
	//1
	//)
	//{\displaystyle 2T(k,r)+T(n-k,r-1)} ходов. Значение
	//�
	//k выбирается таким образом, чтобы значение этого выражения было минимальным. В случае 4 стержней, оптимальное
	//�
	//k равно
	//�
	//−
	//⌊
	//2
	//�
	//+
	//1
	//⌉
	//+
	//1
	//{\displaystyle n-\left\lfloor {\sqrt {2n+1}}\right\rceil +1}, где
	//⌊
	//⋅
	//⌉
	//{\displaystyle \left\lfloor \cdot \right\rceil } — это функция ближайшего целого.[8]
	//T()
	//fmt.Fprintln(out, k)

}
